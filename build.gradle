// =============================================================================
// TickLoom: Distributed Systems Library Build Configuration
// =============================================================================

plugins {
    id 'java'
    id 'dev.clojurephant.clojure' version '0.8.0'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
    id 'signing'
    id 'com.vanniktech.maven.publish' version '0.34.0'
}

// =============================================================================
// Project Properties
// =============================================================================

group = 'io.github.unmeshjoshi'
version = '0.1.0-alpha.7'

// Version catalog for dependency management
ext {
    versions = [
        jackson: '2.17.0',
        rocksdb: '9.7.3',
        jepsen: '0.3.9',
        junit: '5.10.2',
        mockito: '5.11.0'
    ]
    
    mainClasses = [
        server: 'com.tickloom.cmd.ServerMain',
        client: 'com.tickloom.cmd.ClientMain'
    ]
    
    projectMetadata = [
        name: 'TickLoom',
        description: 'A distributed systems library implementing Raft consensus, quorum-based replication, and other distributed algorithms with comprehensive testing infrastructure',
        url: 'https://github.com/unmeshjoshi/tickloom',
        license: [
            name: 'The Apache License, Version 2.0',
            url: 'http://www.apache.org/licenses/LICENSE-2.0.txt'
        ],
        developer: [
            id: 'unmeshjoshi',
            name: 'Unmesh Joshi',
            email: 'unmeshjoshi@gmail.com'
        ],
        scm: [
            connection: 'scm:git:git://github.com/unmeshjoshi/tickloom.git',
            developerConnection: 'scm:git:ssh://github.com/unmeshjoshi/tickloom.git',
            url: 'https://github.com/unmeshjoshi/tickloom'
        ]
    ]
}

// =============================================================================
// Repositories
// =============================================================================

repositories {
    mavenCentral()
    maven { url 'https://clojars.org/repo' }
}

// =============================================================================
// Dependencies
// =============================================================================

dependencies {
    // Core JSON/YAML processing
    implementation "com.fasterxml.jackson.core:jackson-databind:${versions.jackson}"
    implementation "com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:${versions.jackson}"

    // Production-ready storage
    implementation "org.rocksdb:rocksdbjni:${versions.rocksdb}"

    testRuntimeOnly 'dev.clojurephant:jovial:0.4.2'
    testImplementation "jepsen:jepsen:${versions.jepsen}"     // Testing framework (Jepsen pulls org.clojure:clojure transitively)
    testImplementation "org.junit.jupiter:junit-jupiter:${versions.junit}"
    testImplementation "org.mockito:mockito-core:${versions.mockito}"
}

// =============================================================================
// Java Configuration
// =============================================================================

java {
    withSourcesJar()
    // withJavadocJar() - handled by vanniktech plugin
}

// =============================================================================
// Testing Configuration
// =============================================================================

test {
    useJUnitPlatform()
    
    testLogging {
        events 'passed', 'skipped', 'failed', 'standardOut', 'standardError'
        outputs.upToDateWhen { false }
        showStandardStreams = true
    }
}

tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
    failOnError = false
}

// =============================================================================
// Shadow JAR Configuration
// =============================================================================

def configureMetaInfExclusions = { task ->
    task.exclude 'META-INF/*.DSA'
    task.exclude 'META-INF/*.RSA'
    task.exclude 'META-INF/*.SF'
}

shadowJar {
    archiveBaseName.set('tickloom-server')
    archiveClassifier.set('all')
    archiveVersion.set('')
    
    mergeServiceFiles()
    configureMetaInfExclusions(delegate)
    
    manifest {
        attributes 'Main-Class': mainClasses.server
    }
}

tasks.register('shadowClientJar', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    group = 'build'
    description = 'Creates a fat JAR for the client application'
    
    from sourceSets.main.output
    configurations = [project.configurations.runtimeClasspath]
    
    archiveBaseName.set('tickloom-client')
    archiveClassifier.set('all')
    archiveVersion.set('')
    
    mergeServiceFiles()
    configureMetaInfExclusions(delegate)
    
    manifest {
        attributes 'Main-Class': mainClasses.client
    }
}

// =============================================================================
// Application Tasks
// =============================================================================

def createScriptExecutionTask = { taskName, scriptPath, taskGroup, taskDescription, extraArgs = [] ->
    tasks.register(taskName, Exec) {
        group = taskGroup
        description = taskDescription
        dependsOn shadowJar, shadowClientJar
        
        doFirst {
            exec {
                commandLine 'chmod', '+x', scriptPath
                ignoreExitValue = true
            }
        }
        
        commandLine([scriptPath] + extraArgs)
        
        if (taskName == 'runCluster') {
            doLast {
                if (executionResult.get().exitValue != 0) {
                    logger.warn("Cluster test failed, ensuring cleanup...")
                    try {
                        exec {
                            commandLine './scripts/kill-servers.sh'
                            ignoreExitValue = true
                        }
                    } catch (Exception e) {
                        logger.warn("Cleanup script failed: ${e.message}")
                    }
                }
            }
        }
    }
}

createScriptExecutionTask(
    'runCluster', 
    './scripts/run-cluster.sh', 
    'application', 
    'Runs a 3-node distributed cluster test with client operations'
)

createScriptExecutionTask(
    'testIndividualServers', 
    './scripts/test-individual-servers.sh', 
    'verification', 
    'Tests each server individually to verify data replication',
    ['--nodes', '3', '--factory', 'com.tickloom.algorithms.replication.quorum.QuorumReplicaProcessFactory']
)

tasks.register('inspectData') {
    group = 'verification'
    description = 'Inspect the data directory to verify stored values'
    
    doLast {
        def dataDir = file('build/demo-data')
        if (!dataDir.exists()) {
            logger.lifecycle("Data directory does not exist: ${dataDir.absolutePath}")
            logger.lifecycle("Run './gradlew runCluster' first to generate data")
            return
        }
        
        logger.lifecycle("Data directory: ${dataDir.absolutePath}")
        logger.lifecycle("Inspecting RocksDB files...")
        
        dataDir.eachDir { replicaDir ->
            logger.lifecycle("\nReplica: ${replicaDir.name}")
            if (replicaDir.exists()) {
                def files = replicaDir.listFiles()
                if (files) {
                    files.each { file ->
                        logger.lifecycle("  ðŸ“„ ${file.name} (${file.length()} bytes)")
                    }
                } else {
                    logger.lifecycle("  No files found")
                }
            } else {
                logger.lifecycle("  Directory not found")
            }
        }
        
        logger.lifecycle("\nðŸ’¡ To inspect RocksDB contents, you can use:")
        logger.lifecycle("  - RocksDB CLI tools (if installed)")
        logger.lifecycle("  - Or run individual server tests: './gradlew testIndividualServers'")
    }
}

// =============================================================================
// Maven Central Publishing (Main Library)
// =============================================================================

mavenPublishing {
    publishToMavenCentral()
    signAllPublications()
    
    pom {
        name = projectMetadata.name
        description = projectMetadata.description
        url = projectMetadata.url

        licenses {
            license {
                name = projectMetadata.license.name
                url = projectMetadata.license.url
            }
        }

        developers {
            developer {
                id = projectMetadata.developer.id
                name = projectMetadata.developer.name
                email = projectMetadata.developer.email
            }
        }

        scm {
            connection = projectMetadata.scm.connection
            developerConnection = projectMetadata.scm.developerConnection
            url = projectMetadata.scm.url
        }
    }
}

// =============================================================================
// Testkit Publishing Configuration
// =============================================================================

def testkitConfig = [
    includes: ['com/tickloom/**'],
    classExcludes: [
        '**/*Test.class',
        '**/*Test$*.class',
        '**/*Tests.class',
        '**/*Tests$*.class'
    ],
    sourceExcludes: [
        '**/*Test.java',
        '**/*Tests.java'
    ]
]

tasks.register('testkitJar', Jar) {
    group = 'publishing'
    description = 'Complete testing infrastructure: SimulatedNetwork, Jepsen, consistency checkers, and more'
    archiveBaseName.set("${project.name}-testkit")
    duplicatesStrategy = DuplicatesStrategy.WARN
    
    from(sourceSets.test.output) {
        include testkitConfig.includes
        exclude testkitConfig.classExcludes
    }
    from(layout.buildDirectory.dir('clojure/test')) {
        include '**/*.class'
    }
    dependsOn tasks.named('testClasses')
}

tasks.register('testkitSourcesJar', Jar) {
    group = 'publishing'
    description = 'Sources for complete testing infrastructure including Clojure checkers'
    archiveBaseName.set("${project.name}-testkit")
    archiveClassifier.set('sources')
    from(sourceSets.test.allSource) {
        include testkitConfig.includes
        exclude testkitConfig.sourceExcludes
    }
}

tasks.register('testkitJavadoc', Javadoc) {
    group = 'documentation'
    description = 'Javadoc for complete testing infrastructure'
    source = sourceSets.test.allJava.matching {
        include testkitConfig.includes
        exclude testkitConfig.sourceExcludes
    }
    classpath = sourceSets.test.compileClasspath + sourceSets.main.output
    destinationDir = layout.buildDirectory.dir('docs/testkitJavadoc').get().asFile
    options.addStringOption('Xdoclint:none', '-quiet')
    failOnError = false
}

tasks.register('testkitJavadocJar', Jar) {
    group = 'publishing'
    description = 'Javadoc JAR for complete testing infrastructure'
    archiveBaseName.set("${project.name}-testkit")
    archiveClassifier.set('javadoc')
    from(tasks.named('testkitJavadoc'))
    dependsOn tasks.named('testkitJavadoc')
}

def addTestkitDependency = { deps, groupId, artifactId, version, scope, optional = false ->
    def dep = deps.appendNode('dependency')
    dep.appendNode('groupId', groupId)
    dep.appendNode('artifactId', artifactId)
    dep.appendNode('version', version)
    dep.appendNode('scope', scope)
    if (optional) {
        dep.appendNode('optional', 'true')
    }
}

publishing {
    publications {
        mavenTestkit(MavenPublication) {
            artifactId = "${project.name}-testkit"

            artifact tasks.named('testkitJar')
            artifact tasks.named('testkitSourcesJar')
            artifact tasks.named('testkitJavadocJar')

            pom {
                name = 'TickLoom Testkit'
                description = 'Complete distributed systems testing framework with Jepsen, SimulatedNetwork, consistency checkers, and Clojure integration'
                url = projectMetadata.url
                
                licenses {
                    license {
                        name = projectMetadata.license.name
                        url = projectMetadata.license.url
                    }
                }
                
                developers {
                    developer {
                        id = projectMetadata.developer.id
                        name = projectMetadata.developer.name
                        email = projectMetadata.developer.email
                    }
                }
                
                scm {
                    connection = projectMetadata.scm.connection
                    developerConnection = projectMetadata.scm.developerConnection
                    url = projectMetadata.scm.url
                }
                
                withXml {
                    def deps = asNode().appendNode('dependencies')
                    
                    // Main TickLoom library dependency
                    addTestkitDependency(deps, project.group.toString(), project.name, project.version.toString(), 'compile')
                    
                    // Jepsen dependency (includes Clojure + Knossos transitively)
                    addTestkitDependency(deps, 'jepsen', 'jepsen', versions.jepsen, 'compile')
                    
                    // Optional test dependencies
                    addTestkitDependency(deps, 'org.junit.jupiter', 'junit-jupiter', versions.junit, 'test', true)
                    addTestkitDependency(deps, 'org.mockito', 'mockito-core', versions.mockito, 'test', true)
                }
            }
        }
    }
}

// =============================================================================
// Signing Configuration
// =============================================================================

signing {
    def localSigningKeyFile = findProperty('signingKeyFile')
    def localSigningPassword = findProperty('signingPassword')
    
    if (localSigningKeyFile && localSigningPassword) {
        def keyFile = file(localSigningKeyFile.toString())
        if (keyFile.exists()) {
            def signingKey = keyFile.getText('UTF-8')
            useInMemoryPgpKeys(signingKey, localSigningPassword.toString())
            sign publishing.publications.mavenTestkit
            logger.info('Configured signing for testkit publication')
        } else {
            logger.warn("Signing key file not found: ${keyFile.absolutePath}")
        }
    } else {
        logger.info('Signing configuration not found - publications will not be signed')
    }
}
