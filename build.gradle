plugins {
    id 'java'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
    id 'signing'
}

import org.gradle.plugins.signing.Sign

group = 'com.github.tickloom'
version = '0.1.0-alpha.4'

repositories {
    mavenCentral()
    maven { url 'https://repo.clojars.org' } // Knossos is published on Clojars
}

dependencies {
    // Add your dependencies here
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.17.0'
    implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml:2.17.0'
    
    // Production-ready storage
    implementation 'org.rocksdb:rocksdbjni:9.7.3'

    // Knossos pulls org.clojure:clojure transitively (currently 1.12.0)
    testImplementation 'knossos:knossos:0.3.12'
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testImplementation 'org.mockito:mockito-core:5.11.0'
}

// Configure the shadow plugin to create a fat JAR
shadowJar {
    archiveBaseName.set('tickloom-server')
    archiveClassifier.set('all')
    archiveVersion.set('')
    
    // Merge service files (important for RocksDB)
    mergeServiceFiles()
    
    // Exclude development dependencies
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    exclude 'META-INF/*.SF'
    
    // Set the main class for the JAR
    manifest {
        attributes 'Main-Class': 'com.tickloom.cmd.ServerMain'
    }
}

// Create a separate client JAR
task shadowClientJar(type: com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    group = 'build'
    description = 'Creates a fat JAR for the client application'
    
    from sourceSets.main.output
    configurations = [project.configurations.runtimeClasspath]
    
    archiveBaseName.set('tickloom-client')
    archiveClassifier.set('all')
    archiveVersion.set('')
    
    // Merge service files
    mergeServiceFiles()
    
    // Exclude development dependencies
    exclude 'META-INF/*.DSA'
    exclude 'META-INF/*.RSA'
    exclude 'META-INF/*.SF'
    
    // Set the main class for the client JAR
    manifest {
        attributes 'Main-Class': 'com.tickloom.cmd.ClientMain'
    }
}

// Do not tie library jar to shaded apps; keep shadow artifacts separate from the published library

test {
    useJUnitPlatform()
    
    // Show test output including System.out.println
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        outputs.upToDateWhen {false}
        showStandardStreams = true
    }
}

// Task to run the distributed cluster test
task runCluster(type: Exec) {
    group = 'application'
    description = 'Runs a 3-node distributed cluster test with client operations'
    
    // Ensure JARs are built first
    dependsOn shadowJar, shadowClientJar
    
    // Make executable
    doFirst {
        exec {
            commandLine 'chmod', '+x', 'scripts/run-cluster.sh'
        }
    }
    
    commandLine './scripts/run-cluster.sh'
    
    // Handle cleanup on failure
    doLast {
        if (executionResult.get().exitValue != 0) {
            println "Cluster test failed, ensuring cleanup..."
            try {
                exec {
                    commandLine './scripts/kill-servers.sh'
                    ignoreExitValue = true
                }
            } catch (Exception e) {
                println "Cleanup script failed: ${e.message}"
            }
        }
    }
}

// Task to test individual servers
task testIndividualServers(type: Exec) {
    group = 'verification'
    description = 'Tests each server individually to verify data replication'
    
    // Ensure JARs are built first
    dependsOn shadowJar, shadowClientJar
    
    // Make executable
    doFirst {
        exec {
            commandLine 'chmod', '+x', 'scripts/test-individual-servers.sh', 'scripts/run-cluster.sh', 'scripts/kill-servers.sh'
        }
    }
    
    commandLine './scripts/test-individual-servers.sh', '--nodes', '3', '--factory', 'com.tickloom.algorithms.replication.quorum.QuorumReplicaProcessFactory'
}

// Task to inspect data directory
task inspectData {
    group = 'verification'
    description = 'Inspect the data directory to verify stored values'
    
    doLast {
        def dataDir = file('build/demo-data')
        if (!dataDir.exists()) {
            println "‚ùå Data directory does not exist: ${dataDir.absolutePath}"
            println "   Run './gradlew runCluster' first to generate data"
            return
        }
        
        println "üìÅ Data directory: ${dataDir.absolutePath}"
        println "üîç Inspecting RocksDB files..."
        
        dataDir.eachDir { replicaDir ->
            println "\nüìÇ Replica: ${replicaDir.name}"
            if (replicaDir.exists()) {
                def files = replicaDir.listFiles()
                if (files) {
                    files.each { file ->
                        println "   üìÑ ${file.name} (${file.length()} bytes)"
                    }
                } else {
                    println "   ‚ö†Ô∏è  No files found"
                }
            } else {
                println "   ‚ùå Directory not found"
            }
        }
        
        println "\nüí° To inspect RocksDB contents, you can use:"
        println "   - RocksDB CLI tools (if installed)"
        println "   - Or run individual server tests: './gradlew testIndividualServers'"
    }
}

// --- Publishing -------------------------------------------------------------

// Your project's coordinates
group = 'io.github.unmeshjoshi' // Change to your chosen group ID
version = '0.1.0-alpha.4'

java {
    withSourcesJar()
    withJavadocJar()
}

// --- Testkit artifacts (packaged from src/test/java/com/tickloom/testkit/**) ---

tasks.register('testkitJar', Jar) {
    group = 'build'
    description = 'Jar containing the testkit classes for consumers.'
    archiveBaseName.set("${project.name}-testkit")
    from(sourceSets.test.output) {
        include 'com/tickloom/testkit/**'
        include 'com/tickloom/util/StubClock*'
        exclude '**/*Test.class'
    }
    dependsOn tasks.named('testClasses')
}

tasks.register('testkitSourcesJar', Jar) {
    group = 'build'
    description = 'Sources jar for the testkit.'
    archiveBaseName.set("${project.name}-testkit")
    archiveClassifier.set('sources')
    from(sourceSets.test.allSource) {
        include 'com/tickloom/testkit/**'
        include 'com/tickloom/util/StubClock.java'
        exclude '**/*Test.java'
    }
}

tasks.register('testkitJavadoc', Javadoc) {
    description = 'Generates Javadoc for the testkit package.'
    source = sourceSets.test.allJava.matching {
        include 'com/tickloom/testkit/**'
        include 'com/tickloom/util/StubClock.java'
        exclude '**/*Test.java'
    }
    classpath = sourceSets.test.compileClasspath + sourceSets.main.output
    // Use a separate output directory to avoid overlapping with main javadoc
    destinationDir = layout.buildDirectory.dir('docs/testkitJavadoc').get().asFile
}

tasks.register('testkitJavadocJar', Jar) {
    group = 'build'
    description = 'Javadoc jar for the testkit.'
    archiveBaseName.set("${project.name}-testkit")
    archiveClassifier.set('javadoc')
    from(tasks.named('testkitJavadoc'))
    dependsOn tasks.named('testkitJavadoc')
}

// Relax doclint to avoid failing the build on missing Javadoc and minor issues
tasks.withType(Javadoc) {
    options.addStringOption('Xdoclint:none', '-quiet')
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java

            pom {
                name = 'TickLoom'
                description = 'A library for building distributed systems.'
                url = 'https://github.com/unmeshjoshi/tickloom' // Change to your project's URL
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                developers {
                    developer {
                        id = 'unmeshjoshi'
                        name = 'Unmesh Joshi'
                        email = 'unmeshjoshi@gmail.com'
                    }
                }
                scm {
                    connection = 'scm:git:git://github.com/unmeshjoshi/tickloom.git' // Change to your repo's URL
                    developerConnection = 'scm:git:ssh://github.com/unmeshjoshi/tickloom.git' // Change to your repo's URL
                    url = 'https://github.com/unmeshjoshi/tickloom' // Change to your project's URL
                }
            }
        }

        // Separate publication for the testkit
        mavenTestkit(MavenPublication) {
            artifactId = "${project.name}-testkit"

            artifact tasks.named('testkitJar')
            artifact tasks.named('testkitSourcesJar')
            artifact tasks.named('testkitJavadocJar')

            pom {
                name = 'TickLoom Testkit'
                description = 'Testing utilities for TickLoom consumers (use in test scope).'
                url = 'https://github.com/unmeshjoshi/tickloom'
                licenses {
                    license {
                        name = 'The Apache License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                    }
                }
                developers {
                    developer {
                        id = 'unmeshjoshi'
                        name = 'Unmesh Joshi'
                        email = 'unmeshjoshi@gmail.com'
                    }
                }
                scm {
                    connection = 'scm:git:git://github.com/unmeshjoshi/tickloom.git'
                    developerConnection = 'scm:git:ssh://github.com/unmeshjoshi/tickloom.git'
                    url = 'https://github.com/unmeshjoshi/tickloom'
                }
                // Ensure consumers pull the main library alongside testkit
                withXml {
                    def deps = asNode().appendNode('dependencies')
                    def dep = deps.appendNode('dependency')
                    dep.appendNode('groupId', project.group.toString())
                    dep.appendNode('artifactId', project.name)
                    dep.appendNode('version', project.version.toString())
                    dep.appendNode('scope', 'compile')
                }
            }
        }
    }
    repositories {
        maven {
            name = "OSSRH"
            url = "https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/"
            credentials {
                username = (findProperty("ossrhUsername") ?: System.getenv("OSSRH_USERNAME"))
                password = (findProperty("ossrhPassword") ?: System.getenv("OSSRH_PASSWORD"))
            }
        }
    }
}

signing {
    // Support both env vars and Gradle properties for in-memory PGP keys
    def signingKey = System.getenv("OSSRH_GPG_SECRET_KEY") ?: findProperty("signingKey")
    // Also support reading key from a file to avoid newline escaping issues
    def signingKeyFilePath = System.getenv("OSSRH_GPG_SECRET_KEY_FILE") ?: findProperty("signingKeyFile")
    if (!signingKey && signingKeyFilePath) {
        def f = file(signingKeyFilePath.toString())
        if (f.exists()) {
            signingKey = f.getText('UTF-8')
        } else {
            println "Signing key file not found: ${f}"
        }
    }
    def signingPassword = System.getenv("OSSRH_GPG_SECRET_KEY_PASSWORD") ?: findProperty("signingPassword")

    // Only configure signing if keys are present. This avoids failures for local builds.
    if (signingKey && signingPassword) {
        useInMemoryPgpKeys(signingKey.toString(), signingPassword.toString())
        sign publishing.publications
    } else if (findProperty("signing.keyId") && findProperty("signing.password") && findProperty("signing.secretKeyRingFile")) {
        // Fall back to classic keyring-based signing if configured via Gradle properties
        sign publishing.publications
    } else {
        println "Signing disabled: PGP key not configured (set OSSRH_GPG_SECRET_KEY and OSSRH_GPG_SECRET_KEY_PASSWORD or Gradle signingKey/signingPassword)."
    }
}

// --- Central Portal bundle ----------------------------------------------------

// Verify that signing is configured (Central requires .asc signatures)
tasks.register('verifyCentralSigning') {
    group = 'verification'
    doLast {
        def skip = (findProperty('skipCentralSigningCheck')?.toString() == 'true')
        if (!skip) {
            def hasInMemory = (System.getenv('OSSRH_GPG_SECRET_KEY') ?: findProperty('signingKey')) && (System.getenv('OSSRH_GPG_SECRET_KEY_PASSWORD') ?: findProperty('signingPassword'))
            def hasKeyring = findProperty('signing.keyId') && findProperty('signing.password') && findProperty('signing.secretKeyRingFile')
            if (!(hasInMemory || hasKeyring)) {
                throw new GradleException('Signing not configured. Set signingKey/signingPassword or signing.keyId/signing.password/signing.secretKeyRingFile. To bypass for testing, run with -PskipCentralSigningCheck=true')
            }
        } else {
            println 'Skipping central signing verification (-PskipCentralSigningCheck=true)'
        }
    }
}

// Package a bundle zip in Maven repository layout for Central Portal upload
tasks.register('prepareCentralBundle') {
    group = 'distribution'
    description = 'Stages artifacts and signatures into build/central-bundle in Maven repo layout.'
    dependsOn 'assemble', 'sourcesJar', 'javadocJar', 'generatePomFileForMavenJavaPublication'
    // Testkit artifacts and POM
    dependsOn 'testkitJar', 'testkitSourcesJar', 'testkitJavadocJar', 'generatePomFileForMavenTestkitPublication'
    // Ensure signatures exist for both publications if tasks are available
    if (tasks.findByName('signMavenJavaPublication') != null) {
        dependsOn 'signMavenJavaPublication'
    }
    if (tasks.findByName('signMavenTestkitPublication') != null) {
        dependsOn 'signMavenTestkitPublication'
    }
    // If the signing task exists (i.e., signing is configured), ensure signatures are produced
    if (tasks.findByName('signMavenJavaPublication') != null) {
        dependsOn 'signMavenJavaPublication'
    }
    doLast {
        def artifactId = project.name
        def versionStr = project.version.toString()
        def groupPath = project.group.toString().replace('.', '/')
        def mainTargetDir = file("${buildDir}/central-bundle/${groupPath}/${artifactId}/${versionStr}")
        mainTargetDir.mkdirs()
        def testkitArtifactId = "${artifactId}-testkit"
        def testkitTargetDir = file("${buildDir}/central-bundle/${groupPath}/${testkitArtifactId}/${versionStr}")
        testkitTargetDir.mkdirs()

        def pomSrc = file("${buildDir}/publications/mavenJava/pom-default.xml")
        def pomAscSrc = file("${buildDir}/publications/mavenJava/pom-default.xml.asc")
        def pomTestkitSrc = file("${buildDir}/publications/mavenTestkit/pom-default.xml")
        def pomTestkitAscSrc = file("${buildDir}/publications/mavenTestkit/pom-default.xml.asc")
        def jarSrc = tasks.jar.archiveFile.get().asFile
        def sourcesSrc = tasks.sourcesJar.archiveFile.get().asFile
        def javadocSrc = tasks.javadocJar.archiveFile.get().asFile
        // Find signatures; prefer publications, fallback to libs
        def jarAscCandidates = [
                file("${buildDir}/publications/mavenJava/${artifactId}-${versionStr}.jar.asc"),
                file("${buildDir}/libs/${artifactId}-${versionStr}.jar.asc")
        ]
        def sourcesAscCandidates = [
                file("${buildDir}/publications/mavenJava/${artifactId}-${versionStr}-sources.jar.asc"),
                file("${buildDir}/libs/${artifactId}-${versionStr}-sources.jar.asc")
        ]
        def javadocAscCandidates = [
                file("${buildDir}/publications/mavenJava/${artifactId}-${versionStr}-javadoc.jar.asc"),
                file("${buildDir}/libs/${artifactId}-${versionStr}-javadoc.jar.asc")
        ]

        // Main module POM and artifacts
        copy { from(pomSrc); into(mainTargetDir); rename { "${artifactId}-${versionStr}.pom" } }
        if (pomAscSrc.exists()) { copy { from(pomAscSrc); into(mainTargetDir); rename { "${artifactId}-${versionStr}.pom.asc" } } }
        copy { from(jarSrc); into(mainTargetDir) }
        copy { from(sourcesSrc); into(mainTargetDir) }
        copy { from(javadocSrc); into(mainTargetDir) }

        // Testkit POM and artifacts
        copy { from(pomTestkitSrc); into(testkitTargetDir); rename { "${testkitArtifactId}-${versionStr}.pom" } }
        if (pomTestkitAscSrc.exists()) { copy { from(pomTestkitAscSrc); into(testkitTargetDir); rename { "${testkitArtifactId}-${versionStr}.pom.asc" } } }
        def testkitJarFile = tasks.named('testkitJar').get().archiveFile.get().asFile
        def testkitSourcesFile = tasks.named('testkitSourcesJar').get().archiveFile.get().asFile
        def testkitJavadocFile = tasks.named('testkitJavadocJar').get().archiveFile.get().asFile
        copy { from(testkitJarFile); into(testkitTargetDir) }
        copy { from(testkitSourcesFile); into(testkitTargetDir) }
        copy { from(testkitJavadocFile); into(testkitTargetDir) }

        [jarAscCandidates, sourcesAscCandidates, javadocAscCandidates].each { List<File> candidates ->
            def found = candidates.find { it.exists() }
            if (found) { copy { from(found); into(mainTargetDir) } }
        }

        // Testkit signatures (prefer publications, fallback to build/libs)
        def testkitJarAscCandidates = [
                file("${buildDir}/publications/mavenTestkit/${testkitArtifactId}-${versionStr}.jar.asc"),
                file("${buildDir}/libs/${testkitArtifactId}-${versionStr}.jar.asc")
        ]
        def testkitSourcesAscCandidates = [
                file("${buildDir}/publications/mavenTestkit/${testkitArtifactId}-${versionStr}-sources.jar.asc"),
                file("${buildDir}/libs/${testkitArtifactId}-${versionStr}-sources.jar.asc")
        ]
        def testkitJavadocAscCandidates = [
                file("${buildDir}/publications/mavenTestkit/${testkitArtifactId}-${versionStr}-javadoc.jar.asc"),
                file("${buildDir}/libs/${testkitArtifactId}-${versionStr}-javadoc.jar.asc")
        ]
        [testkitJarAscCandidates, testkitSourcesAscCandidates, testkitJavadocAscCandidates].each { List<File> candidates ->
            def found = candidates.find { it.exists() }
            if (found) { copy { from(found); into(testkitTargetDir) } }
        }

        // Generate MD5 and SHA1 checksums required by Central validation
        def filesNeedingChecksums = [
                new File(mainTargetDir, "${artifactId}-${versionStr}.pom"),
                new File(mainTargetDir, "${artifactId}-${versionStr}.jar"),
                new File(mainTargetDir, "${artifactId}-${versionStr}-sources.jar"),
                new File(mainTargetDir, "${artifactId}-${versionStr}-javadoc.jar"),
                new File(testkitTargetDir, "${testkitArtifactId}-${versionStr}.pom"),
                new File(testkitTargetDir, "${testkitArtifactId}-${versionStr}.jar"),
                new File(testkitTargetDir, "${testkitArtifactId}-${versionStr}-sources.jar"),
                new File(testkitTargetDir, "${testkitArtifactId}-${versionStr}-javadoc.jar")
        ]

        def computeDigestHex = { File f, String algo ->
            def md = java.security.MessageDigest.getInstance(algo)
            f.withInputStream { is ->
                byte[] buf = new byte[8192]
                int read
                while ((read = is.read(buf)) != -1) {
                    md.update(buf, 0, read)
                }
            }
            return md.digest().collect { String.format('%02x', it) }.join()
        }

        filesNeedingChecksums.each { File f ->
            if (f.exists()) {
                def md5 = computeDigestHex(f, 'MD5')
                def sha1 = computeDigestHex(f, 'SHA-1')
                new File(f.parentFile, f.name + '.md5').text = md5
                new File(f.parentFile, f.name + '.sha1').text = sha1
            } else {
                logger.warn("Central bundle: missing expected file ${f.name} when generating checksums")
            }
        }
    }
}

tasks.register('createCentralBundle', Zip) { z ->
    group = 'distribution'
    description = 'Creates a bundle ZIP (Maven repo layout) for upload to Central Portal.'
    dependsOn 'prepareCentralBundle'

    def artifactId = project.name
    def versionStr = project.version.toString()
    def groupPath = project.group.toString().replace('.', '/')

    archiveBaseName.set("${artifactId}-${versionStr}-bundle")
    destinationDirectory.set(layout.buildDirectory.dir('distributions'))

    from(layout.buildDirectory.dir('central-bundle')) { include("${groupPath}/**") }
}
